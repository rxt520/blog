(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{362:function(_,v,e){"use strict";e.r(v);var t=e(3),n=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"mysql面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql面试题"}},[_._v("#")]),_._v(" MySql面试题")]),_._v(" "),e("h2",{attrs:{id:"索引面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#索引面试题"}},[_._v("#")]),_._v(" 索引面试题")]),_._v(" "),e("p",[e("strong",[_._v("转载：https://mp.weixin.qq.com/s/_bk2JVOm2SkXfdcvki6-0w")])]),_._v(" "),e("p",[e("strong",[_._v("1")]),_._v("."),e("strong",[_._v("索引概念、索引模型")])]),_._v(" "),e("p",[_._v("我们是怎么聊到索引的呢，是因为我提到我们的业务量比较大，每天大概有几百万的新数据生成，于是有了以下对话：")]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("你们每天这么大的数据量，都是保存在关系型数据库中吗？")])]),_._v(" "),e("p",[_._v("**A：**是的，我们线上使用的是MySQL数据库")]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("每天几百万数据，一个月就是几千万了，那你们有没有对于查询做一些优化呢？")])]),_._v(" "),e("p",[_._v("**A：**我们在数据库中创建了一些索引（我现在非常后悔我当时说了这句话）")]),_._v(" "),e("p",[_._v("这里可以看到，阿里的面试官并不会像有一些公司一样拿着题库一道一道的问，而是会根据面试者做过的事情以及面试过程中的一些内容进行展开。")]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("那你能说说什么是索引吗？")])]),_._v(" "),e("p",[e("strong",[_._v("A：")]),_._v("（这道题肯定难不住我啊）索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据")]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("那么索引具体采用的哪种数据结构呢？")])]),_._v(" "),e("p",[e("strong",[_._v("A：")]),_._v("（这道题我也背过）常见的MySQL主要有两种结构：Hash索引和B+ Tree索引，我们使用的是InnoDB引擎，默认的是B+树")]),_._v(" "),e("p",[_._v("这里我耍了一个小心机，特意说了一下索引和存储引擎有关。希望面试官可以问我一些关于存储引擎的问题。然而面试官并没有被我带跑...")]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("既然你提到InnoDB使用的B+ 树的索引模型，那么你知道为什么采用B+ 树吗？这和Hash索引比较起来有什么优缺点吗？")])]),_._v(" "),e("p",[e("strong",[_._v("A：")]),_._v("（突然觉得这道题有点难，但是我还是凭借着自己的知识储备简单的回答上一些）因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。**所以，哈希索引只适用于等值查询的场景。**而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描")]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("除了上面这个范围查询的，你还能说出其他的一些区别吗？")])]),_._v(" "),e("p",[e("strong",[_._v("A：")]),_._v("（这个题我回答的不好，事后百度了一下）")]),_._v(" "),e("p",[_._v("B+ Tree索引和Hash索引区别？")]),_._v(" "),e("p",[_._v("哈希索引适合等值查询，但是无法进行范围查询")]),_._v(" "),e("p",[_._v("哈希索引没办法利用索引完成排序")]),_._v(" "),e("p",[_._v("哈希索引不支持多列联合索引的最左匹配规则")]),_._v(" "),e("p",[_._v("如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题")]),_._v(" "),e("p",[e("strong",[_._v("2")]),_._v("."),e("strong",[_._v("聚簇索引、覆盖索引")])]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("刚刚我们聊到B+ Tree ，那你知道B+ Tree的叶子节点都可以存哪些东西吗？")])]),_._v(" "),e("p",[_._v("**A：**InnoDB的B+ Tree可能存储的是整行数据，也有可能是主键的值")]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("那这两者有什么区别吗？")])]),_._v(" "),e("p",[e("strong",[_._v("A：")]),_._v("（当他问我叶子节点的时候，其实我就猜到他可能要问我聚簇索引和非聚簇索引了）在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引")]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("那么，聚簇索引和非聚簇索引，在查询数据的时候有区别吗？")])]),_._v(" "),e("p",[_._v("**A：**聚簇索引查询会更快？")]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("为什么呢？")])]),_._v(" "),e("p",[_._v("**A：**因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询")]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("刚刚你提到主键索引查询只会查一次，而非主键索引需要回表查询多次。（后来我才知道，原来这个过程叫做*"),e("em",[_._v("回表*")]),_._v("）是所有情况都是这样的吗？非主键索引一定会查询多次吗？")])]),_._v(" "),e("p",[e("strong",[_._v("A：")]),_._v("（额、这个问题我回答的不好，后来我自己查资料才知道，通过"),e("strong",[_._v("覆盖索引")]),_._v("也可以只查询一次）")]),_._v(" "),e("p",[_._v("覆盖索引？")]),_._v(" "),e("p",[_._v("覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。")]),_._v(" "),e("p",[_._v("当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。")]),_._v(" "),e("p",[_._v("如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。")]),_._v(" "),e("p",[_._v("当我们通过SQL语句：select key2 from covering_index_sample where key1 = 'keytest';的时候，就可以通过覆盖索引查询，无需回表。")]),_._v(" "),e("p",[e("strong",[_._v("3")]),_._v("."),e("strong",[_._v("联合索引、最左前缀匹配")])]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("不知道的话没关系，想问一下，你们在创建索引的时候都会考虑哪些因素呢？")])]),_._v(" "),e("p",[_._v("**A：**我们一般对于查询概率比较高，经常作为where条件的字段设置索引")]),_._v(" "),e("p",[e("strong",[_._v("Q：")]),_._v(" "),e("strong",[_._v("那你们有用过联合索引吗？")])]),_._v(" "),e("p",[_._v("**A：**用过呀，我们有对一些表中创建过联合索引")]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("那你们在创建联合索引的时候，需要做联合索引多个字段之间顺序你们是如何选择的呢？")])]),_._v(" "),e("p",[_._v("**A：**我们把识别度最高的字段放到最前面")]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("为什么这么做呢？")])]),_._v(" "),e("p",[e("strong",[_._v("A：")]),_._v("（这个问题有点把我问蒙了，稍微有些慌乱）这样的话可能命中率会高一点吧。。。")]),_._v(" "),e("p",[e("strong",[_._v("Q：")]),_._v(" "),e("strong",[_._v("那你知道最左前缀匹配吗？")])]),_._v(" "),e("p",[e("strong",[_._v("A：")]),_._v("（我突然想起来原来面试官是想问这个，怪自己刚刚为什么就没想到这个呢。）哦哦哦。您刚刚问的是这个意思啊，在创建多列索引时，我们根据业务需求，where子句中使用最频繁的一列放在最左边，因为MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则")]),_._v(" "),e("p",[_._v("虽然我一开始有点懵，没有联想到最左前缀匹配，但是面试官还是引导了我。很友善。")]),_._v(" "),e("p",[e("strong",[_._v("4")]),_._v("."),e("strong",[_._v("索引下推、查询优化")])]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("你们线上用的MySQL是哪个版本啊呢？")])]),_._v(" "),e("p",[_._v("**A：**我们MySQL是5.7")]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("那你知道在MySQL 5.6中，对索引做了哪些优化吗？")])]),_._v(" "),e("p",[_._v("**A：**不好意思，这个我没有去了解过。（事后我查了一下，有一个比较重要的 ：Index Condition Pushdown Optimization）")]),_._v(" "),e("p",[_._v("Index Condition Pushdown（索引下推）")]),_._v(" "),e("p",[_._v("MySQL 5.6引入了索引下推优化，默认开启，使用SET optimizer_switch = 'index_condition_pushdown=off';可以将其关闭。官方文档中给的例子和解释如下：")]),_._v(" "),e("p",[_._v("people表中（zipcode，lastname，firstname）构成一个索引")]),_._v(" "),e("p",[_._v("SELECT * FROM people WHERE zipcode='95054' AND lastname LIKE '%etrunia%' AND address LIKE '%Main Street%';")]),_._v(" "),e("p",[_._v("如果没有使用索引下推技术，则MySQL会通过zipcode='95054'从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断数据是否符合条件。")]),_._v(" "),e("p",[_._v("如果使用了索引下推技术，则MYSQL首先会返回符合zipcode='95054'的索引，然后根据lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。")]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("你们创建的那么多索引，到底有没有生效，或者说你们的SQL语句有没有使用索引查询你们有统计过吗？")])]),_._v(" "),e("p",[_._v("**A：**这个还没有统计过，除非遇到慢SQL的时候我们才会去排查")]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("那排查的时候，有什么手段可以知道有没有走索引查询呢？")])]),_._v(" "),e("p",[_._v("**A：**可以通过explain查看sql语句的执行计划，通过执行计划来分析索引使用情况")]),_._v(" "),e("p",[_._v("**Q：**"),e("strong",[_._v("那什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢？")])]),_._v(" "),e("p",[e("strong",[_._v("A：")]),_._v("（大概记得和优化器有关，但是这个问题并没有回答好）")]),_._v(" "),e("p",[_._v("查询优化器？")]),_._v(" "),e("p",[_._v("一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。")]),_._v(" "),e("p",[_._v("在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。")]),_._v(" "),e("p",[_._v("这个成本最低的方案就是所谓的执行计划。优化过程大致如下：")]),_._v(" "),e("p",[_._v("1、根据搜索条件，找出所有可能使用的索引")]),_._v(" "),e("p",[_._v("2、计算全表扫描的代价")]),_._v(" "),e("p",[_._v("3、计算使用不同索引执行查询的代价")]),_._v(" "),e("p",[_._v("4、对比各种执行方案的代价，找出成本最低的那一个")])])}),[],!1,null,null,null);v.default=n.exports}}]);